<!DOCTYPE html>
</html>
</body>
  </script>
</body>
</html>
<!DOCTYPE html>
</html>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Edge-Spawn TD - Prototype</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6edf3; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; user-select: none; overflow: hidden; }
    body { display: flex; flex-direction: column; height: 100%; }
    #wrap { display: grid; grid-template-columns: 1fr 340px; grid-template-rows: 1fr; flex: 1; min-height: 0; width: 100%; }
    #gameCanvas { display: block; width: 100%; height: 100%; background: radial-gradient(1200px 800px at 40% 60%, #0f1520 0%, #0c121a 55%, #0b0f14 100%); outline: 1px solid rgba(255,255,255,0.04); }
    #ui { background: linear-gradient(180deg, rgba(20,26,36,.9), rgba(12,18,26,.9)); border-left: 1px solid rgba(255,255,255,0.06); padding: 14px 14px 24px 14px; display: flex; flex-direction: column; gap: 10px; }
    .section { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .big { font-size: 22px; font-weight: 700; letter-spacing: .3px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); font-size: 12px; letter-spacing:.3px; text-transform: uppercase; }
    button { background: #1e293b; color: #e6edf3; border: 1px solid rgba(255,255,255,0.12); padding: 8px 10px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
    button.can-upgrade { background: #2563eb; border-color: rgba(255,255,255,0.35); color: #f8fafc; box-shadow: 0 0 12px rgba(37,99,235,0.35); }
    button:disabled { opacity: .4; cursor: not-allowed; background: #111827; border-color: rgba(255,255,255,0.08); box-shadow: none; }
    .kbd { border: 1px solid rgba(255,255,255,0.24); padding: 2px 6px; border-radius: 6px; font-size: 12px; background: #0d1420; margin: 0 2px; }
    #buildBar { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; width:100%; }
    .towerBtn { flex:1; display:flex; flex-direction:column; gap:6px; align-items:flex-start; padding:10px; background:#0e1522; border:1px solid rgba(255,255,255,0.08); border-radius: 10px; }
    .muted { color: #9fb1c1; font-size: 12px; }
    .towerStats { white-space: pre-line; }
    #overlay { position: absolute; inset: 0 340px 0 0; pointer-events: none; display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:.4px; }
    .overlayCard { pointer-events: all; background: rgba(10,14,20,0.88); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; padding: 18px 22px; display:flex; flex-direction:column; gap:10px; align-items: center; text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .inlineBadges { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
    .hint { color:#a8b7c6; font-size: 13px; }
    a { color: #87cefa; text-decoration: none; }
    #overlay[hidden] { display: none !important; }
    .dropLine { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:4px 0; }
    .dropName { display:flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
    .dot.ms { background:#60a5fa; } .dot.crit { background:#f87171; } .dot.bnc { background:#a78bfa; } .dot.hp { background:#22c55e; } .dot.ls { background:#f59e0b; }
    #controlBar { background: linear-gradient(180deg, rgba(12,18,26,0.95), rgba(9,12,20,0.95)); border-top: 1px solid rgba(255,255,255,0.06); padding: 14px 18px; }
    #controlBarInner { max-width: 1120px; margin: 0 auto; }
    .towerBtn.utility { justify-content: space-between; }
    .utilityActions { display:flex; flex-direction:column; gap:8px; width:100%; }
    .utilityActions button { width:100%; }
    @media (max-width: 980px) {
      #wrap { grid-template-columns: 1fr; }
      #overlay { inset: 0; }
      #ui { position: absolute; inset: auto 0 0 0; height: fit-content; max-height: 48vh; overflow: auto; }
      #controlBar { padding: 12px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="gameCanvas"></canvas>
    <aside id="ui">
      <div class="row"><div class="big">Edge-Spawn TD</div><div class="pill mono" id="version">Prototype r8</div></div>

      <div class="section" id="stats">
        <div class="row"><div>Wave</div><div class="mono" id="wave">0</div></div>
        <div class="row"><div>XP</div><div class="mono" id="xp">0</div></div>
        <div class="row"><div>Towers</div><div class="mono" id="towerCount">0</div></div>
        <div class="row"><div>Enemies</div><div class="mono" id="enemyCount">0</div></div>
      </div>

      <div class="section">
        <div class="row" style="margin-bottom:6px"><strong>Tech Upgrades (snapshot at placement)</strong></div>
        <div class="row">
          <div>Rapid Tech <span class="mono" id="rapidLvl">Lv.1</span></div>
          <div class="row" style="gap:6px">
            <button id="buyRapid">Upgrade</button>
            <div class="muted mono" id="rapidCost">Cost: 6 XP</div>
          </div>
        </div>
        <div class="row">
          <div>Beam Tech <span class="mono" id="beamLvl">Lv.1</span></div>
          <div class="row" style="gap:6px">
            <button id="buyBeam">Upgrade</button>
            <div class="muted mono" id="beamCost">Cost: 10 XP</div>
          </div>
        </div>
        <div class="row">
          <div>Wall Tech <span class="mono" id="wallLvl">Lv.1</span></div>
          <div class="row" style="gap:6px">
            <button id="buyWall">Upgrade</button>
            <div class="muted mono" id="wallCost">Cost: 8 XP</div>
          </div>
        </div>
        <div class="muted" style="margin-top:6px">Existing towers do not change; new towers inherit current Tech (Spirit infusion can bump levels).</div>
      </div>

      <div class="section">
        <strong>Items (global, stack)</strong>
        <div class="dropLine"><div class="dropName"><span class="dot crit"></span>Crit Chance</div><div class="mono" id="itmCrit">x0</div></div>
        <div class="dropLine"><div class="dropName"><span class="dot bnc"></span>Bounce</div><div class="mono" id="itmBounce">x0</div></div>
        <div class="dropLine"><div class="dropName"><span class="dot hp"></span>Tower HP</div><div class="mono" id="itmHP">x0</div></div>
        <div class="dropLine"><div class="dropName"><span class="dot ls"></span>Life Steal</div><div class="mono" id="itmLS">x0</div></div>
        <div class="muted" style="margin-top:6px">10% drop chance on kill. Worm boss spawns every 5 waves.</div>
      </div>

      <div class="section">
        <strong>Controls</strong>
        <div class="muted" style="line-height:1.6">
          Select: <span class="kbd">1</span> Rapid, <span class="kbd">2</span> Beam, <span class="kbd">3</span> Wall &bull; Click to place<br/>
          First placement starts Wave 1<br/>
          <span class="kbd">R</span> Restart &bull; <span class="kbd">Space</span> Pause &bull; <span class="kbd">N</span> Next Wave (tap anytime)<br/>
          <span class="kbd">G</span> Toggle Grid Snap &bull; <span class="kbd">Ctrl</span>+Click Remove &bull; Build controls below
        </div>
      </div>

      <div class="row" style="justify-content:center; margin-top:4px; color:#9fb1c1; font-size:12px;">&copy; Prototype for design exploration</div>
    </aside>
  </div>

  <div id="controlBar">
    <div id="controlBarInner">
      <div id="buildBar">
        <div class="towerBtn" id="btnRapid">
          <div class="row" style="width:100%"><div><strong>Rapid</strong></div><div class="pill mono">1</div></div>
          <div class="muted">Fast, low damage bullets. Unlimited range.</div>
          <div class="muted mono towerStats" id="statsRapid">-</div>
          <div class="row" style="width:100%; margin-top:6px"><div class="muted">Cost</div><div class="mono" id="costRapid">5 XP</div></div>
        </div>
        <div class="towerBtn" id="btnBeam">
          <div class="row" style="width:100%"><div><strong>Beam</strong></div><div class="pill mono">2</div></div>
          <div class="muted">Continuous beam damages along its path.</div>
          <div class="muted mono towerStats" id="statsBeam">-</div>
          <div class="row" style="width:100%; margin-top:6px"><div class="muted">Cost</div><div class="mono" id="costBeam">15 XP</div></div>
        </div>
        <div class="towerBtn" id="btnWall">
          <div class="row" style="width:100%"><div><strong>Wall</strong></div><div class="pill mono">3</div></div>
          <div class="muted">Stationary barrier that reflects damage and self-repairs.</div>
          <div class="muted mono towerStats" id="statsWall">-</div>
          <div class="row" style="width:100%; margin-top:6px"><div class="muted">Cost</div><div class="mono" id="costWall">8 XP</div></div>
        </div>
        <div class="towerBtn utility">
          <div class="row" style="width:100%"><div><strong>Utility</strong></div></div>
          <div class="muted">Helpers for placement and summoning support.</div>
          <div class="utilityActions">
            <button id="toggleSnap">Grid Snap: Off</button>
            <button id="btnSpirit">Summon Spirit</button>
          </div>
          <div class="muted mono" id="spiritCost">Cost: 10 XP</div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay" hidden>
    <div class="overlayCard" id="overlayCard">
      <div id="overlayTitle" class="big">Round Over</div>
      <div id="overlayBody" class="hint">All towers were destroyed.</div>
      <div class="inlineBadges">
        <div class="pill mono" id="finalWave">Wave: 0</div>
        <div class="pill mono" id="finalXP">XP: 0</div>
      </div>
      <div>
        <button id="btnRestart">Restart (R)</button>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI elements
    const waveEl = document.getElementById('wave');
    const xpEl = document.getElementById('xp');
    const towerCountEl = document.getElementById('towerCount');
    const enemyCountEl = document.getElementById('enemyCount');
    const rapidLvlEl = document.getElementById('rapidLvl');
    const beamLvlEl = document.getElementById('beamLvl');
    const wallLvlEl = document.getElementById('wallLvl');
    const rapidCostEl = document.getElementById('rapidCost');
    const beamCostEl = document.getElementById('beamCost');
    const wallCostEl = document.getElementById('wallCost');
    const costRapidEl = document.getElementById('costRapid');
    const costBeamEl = document.getElementById('costBeam');
    const costWallEl = document.getElementById('costWall');
    const overlay = document.getElementById('overlay'); overlay.hidden = true;
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayBody = document.getElementById('overlayBody');
    const finalWaveEl = document.getElementById('finalWave');
    const finalXPEl = document.getElementById('finalXP');

    const btnRapid = document.getElementById('btnRapid');
    const statsRapidEl = document.getElementById('statsRapid');
    const statsBeamEl = document.getElementById('statsBeam');
    const statsWallEl = document.getElementById('statsWall');
    const btnBeam = document.getElementById('btnBeam');
    const buyWallBtn = document.getElementById('buyWall');
    const btnWall = document.getElementById('btnWall');
    const btnRestart = document.getElementById('btnRestart');
    const buyRapidBtn = document.getElementById('buyRapid');
    const buyBeamBtn = document.getElementById('buyBeam');
    const toggleSnapBtn = document.getElementById('toggleSnap');
    const spiritBtn = document.getElementById('btnSpirit');
    const spiritCostEl = document.getElementById('spiritCost');

    const itmCritEl = document.getElementById('itmCrit');
    const itmBncEl = document.getElementById('itmBounce');
    const itmHPEl = document.getElementById('itmHP');
    const itmLSEl = document.getElementById('itmLS');

    const UI_RIGHT_PAD = 340; // matches sidebar width
    const GRID_SIZE = 40;
    const SPIRIT_COST = 10;

    const state = {
      width: 1280,
      height: 720,
      time: 0,
      dt: 0,
      last: 0,
      running: true,
      towers: [],
      enemies: [],
      projectiles: [],
      particles: [],
      rings: [],
      drops: [],
      toasts: [],
      wave: 0,
      spawning: false,
      enemiesToSpawn: 0,
      spawnCooldown: 0,
      spawnedThisWave: 0,
      bossSpawned: false,
      xp: 0,
      dropChance: 0.10,
      selected: 'rapid',
      gridSnap: true,
      ctrlDown: false,
      hoverTower: null,
      firstPlaced: false,
      nextWaveQueued: false,
      tech: { rapid: 1, beam: 1, wall: 1 }, // Tech levels (affect future placements)
      items: { crit: 0, bounce: 0, hp: 0, lifesteal: 0 }, // Global items
      costs: { rapid: 5, beam: 15, wall: 8 },
    };

    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const leftWidth = Math.max(340, window.innerWidth - UI_RIGHT_PAD);
      const controlBar = document.getElementById('controlBar');
      const barHeight = controlBar ? controlBar.getBoundingClientRect().height : 0;
      const availableHeight = Math.max(1, window.innerHeight - barHeight);
      const w = leftWidth;
      const h = availableHeight;
      const targetAspect = state.width / state.height;
      let drawW = w;
      let drawH = Math.floor(w / targetAspect);
      if (drawH > h) {
        drawH = h;
        drawW = Math.floor(h * targetAspect);
      }
      canvas.style.width = drawW + 'px';
      canvas.style.height = drawH + 'px';
      canvas.width = Math.floor(drawW * dpr);
      canvas.height = Math.floor(drawH * dpr);
      ctx.setTransform(canvas.width / state.width, 0, 0, canvas.height / state.height, 0, 0);
      const overlayEl = document.getElementById('overlay');
      if (overlayEl) overlayEl.style.bottom = `${barHeight}px`;
    }

    window.addEventListener('resize', resize);

    // Utility helpers
    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const dist2 = (a, b) => (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);

    // Math: distance from point to segment
    function distPointToSeg(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const l2 = dx * dx + dy * dy || 1e-6;
      let t = ((px - x1) * dx + (py - y1) * dy) / l2;
      t = clamp(t, 0, 1);
      const sx = x1 + t * dx;
      const sy = y1 + t * dy;
      return Math.hypot(px - sx, py - sy);
    }

    function computeLeadPoint(px, py, speed, target) {
      const tx = target.x;
      const ty = target.y;
      const vx = target.vx || 0;
      const vy = target.vy || 0;
      const rx = tx - px;
      const ry = ty - py;
      const a = (vx * vx + vy * vy) - speed * speed;
      const b = 2 * (rx * vx + ry * vy);
      const c = rx * rx + ry * ry;
      let t;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) < 1e-6) {
          t = 0;
        } else {
          t = -c / b;
        }
      } else {
        const disc = b * b - 4 * a * c;
        if (disc < 0) return { x: tx, y: ty };
        const sqrt = Math.sqrt(disc);
        const t1 = (-b - sqrt) / (2 * a);
        const t2 = (-b + sqrt) / (2 * a);
        t = Math.min(t1, t2);
        if (t < 0) t = Math.max(t1, t2);
      }
      if (!Number.isFinite(t) || t < 0) t = 0;
      t = clamp(t, 0, 1.4);
      return { x: tx + vx * t, y: ty + vy * t };
    }

    // Drawing helpers
    function roundedRect(g, x, y, width, height, radius) {
      g.beginPath();
      g.moveTo(x + radius, y);
      g.lineTo(x + width - radius, y);
      g.arcTo(x + width, y, x + width, y + height, radius);
      g.lineTo(x + width, y + height - radius);
      g.arcTo(x + width, y + height, x, y + height, radius);
      g.lineTo(x + radius, y + height);
      g.arcTo(x, y + height, x, y, radius);
      g.lineTo(x, y + radius);
      g.arcTo(x, y, x + radius, y, radius);
      g.closePath();
    }

    function drawHpBar(g, x, y, hp, hpMax, style = {}) {
      const w = style.width || 40;
      const h = style.height || 5;
      const bg = style.background || 'rgba(255,255,255,0.08)';
      const fill = style.fill || '#7ee787';
      g.fillStyle = bg;
      roundedRect(g, x - w / 2, y, w, h, 3);
      g.fill();
      const frac = clamp(hp / hpMax, 0, 1);
      if (frac <= 0) return;
      g.fillStyle = fill;
      roundedRect(g, x - w / 2, y, w * frac, h, 3);
      g.fill();
    }

    const dropConfig = {
      crit: { color: '#f87171', label: 'C', toast: '+Crit' },
      bounce: { color: '#a78bfa', label: 'B', toast: '+Bounce' },
      hp: { color: '#22c55e', label: 'HP', toast: '+HP' },
      lifesteal: { color: '#f59e0b', label: 'LS', toast: '+LS' },
      default: { color: '#94a3b8', label: '?', toast: '+Item' },
    };

    function spawnDrop(key, x, y) {
      const cfg = dropConfig[key] || dropConfig.default;
      state.drops.push({
        key,
        x,
        y,
        vx: rand(-40, 40),
        vy: rand(-140, -80),
        radius: 16,
        collected: false,
        age: 0,
        color: cfg.color,
      });
    }

    function collectDrop(drop) {
      if (drop.collected) return;
      drop.collected = true;
      const cfg = dropConfig[drop.key] || dropConfig.default;
      const applied = onItemGained(drop.key);
      addParticle(drop.x, drop.y, cfg.color);
      const toastText = applied ? cfg.toast : `${cfg.label} MAX`;
      pushToast(toastText, drop.x, drop.y);
    }

    function autoCollectDrops() {
      if (state.drops.length === 0) return;
      for (const drop of state.drops) collectDrop(drop);
      state.drops = state.drops.filter((d) => !d.collected);
    }

    function updateDrops(dt) {
      if (state.drops.length === 0) return;
      for (const drop of state.drops) {
        drop.age += dt;
        drop.vy += 220 * dt;
        drop.vx *= 0.98;
        drop.vy *= 0.98;
        const dx = mouse.x - drop.x;
        const dy = mouse.y - drop.y;
        const dist = Math.hypot(dx, dy) || 1;
        if (dist < 120) {
          const pull = (120 - dist) / 120;
          const strength = 220;
          drop.vx += (dx / dist) * strength * pull * dt;
          drop.vy += (dy / dist) * strength * pull * dt;
        }
        drop.x += drop.vx * dt;
        drop.y += drop.vy * dt;
        drop.x = clamp(drop.x, 20, state.width - 20);
        drop.y = clamp(drop.y, 20, state.height - 20);
        const hoverDist = Math.hypot(drop.x - mouse.x, drop.y - mouse.y);
        if (hoverDist < drop.radius) collectDrop(drop);
      }
      state.drops = state.drops.filter((d) => !d.collected);
    }

    function drawDrops(g) {
      for (const drop of state.drops) {
        const cfg = dropConfig[drop.key] || dropConfig.default;
        g.save();
        g.translate(drop.x, drop.y);
        g.fillStyle = 'rgba(11,15,20,0.9)';
        g.beginPath();
        g.arc(0, 0, drop.radius + 2, 0, Math.PI * 2);
        g.fill();
        g.fillStyle = cfg.color;
        g.beginPath();
        g.arc(0, 0, drop.radius, 0, Math.PI * 2);
        g.fill();
        g.fillStyle = '#0b0f14';
        g.font = '14px sans-serif';
        g.textAlign = 'center';
        g.textBaseline = 'middle';
        g.fillText(cfg.label, 0, 1);
        g.restore();
      }
    }

    function pushToast(text, x, y) {
      state.toasts.push({
        text,
        x,
        y,
        life: 0,
        ttl: 1.2,
        vy: -20,
      });
    }

    function updateToasts(dt) {
      if (state.toasts.length === 0) return;
      for (const toast of state.toasts) {
        toast.life += dt;
        toast.y += toast.vy * dt;
        toast.vy -= 12 * dt;
      }
      state.toasts = state.toasts.filter((t) => t.life < t.ttl);
    }

    function drawToasts(g) {
      if (state.toasts.length === 0) return;
      g.save();
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.font = '16px sans-serif';
      for (const toast of state.toasts) {
        const alpha = clamp(1 - toast.life / toast.ttl, 0, 1);
        g.globalAlpha = alpha;
        g.fillStyle = '#ffffff';
        g.fillText(toast.text, toast.x, toast.y);
      }
      g.restore();
    }

    // Global item math
    const critMult = 2.0;
    function getCritChance() { return state.items.crit * 0.05; } // 5% per stack
    function getLifeSteal() { return state.items.lifesteal * 0.02; } // 2% per stack
    function getBeamWidthBonus() { return 0; }
    function getBeamDpsMult() { return 1; }
    function applyHealFromDamage(tower, rawDmg) {
      if (!tower || tower.kind === 'wall') return;
      const ls = getLifeSteal();
      if (ls <= 0) return;
      tower.hp = Math.min(tower.hpMax, tower.hp + rawDmg * ls);
    }

    class Tower {
      constructor(x, y, kind, snapshot) {
        this.x = x;
        this.y = y;
        this.kind = kind;
        this.snapshot = snapshot; // { level, stats }
        if (this.kind === 'rapid') {
          this.radius = 14;
          this.baseHpMax = 160;
        } else if (this.kind === 'beam') {
          this.radius = 13;
          this.baseHpMax = 210;
        } else if (this.kind === 'wall') {
          this.radius = 16;
          this.baseHpMax = snapshot.hpMax;
        } else {
          this.radius = 16;
          this.baseHpMax = 160;
        }
        this.hpMax = this.baseHpMax * (1 + 0.10 * state.items.hp);
        this.hp = this.hpMax;
        this.cool = 0;
        this.angle = 0;
        this.id = Math.random().toString(36).slice(2, 9);
        if (this.kind === 'beam') {
          this.beamTarget = null;
          this.hasLockedDirection = false;
          this.lastAngle = 0;
          this.beamSegments = [];
          this.lastBeamEnemy = null;
        }
      }

      isAlive() { return this.hp > 0; }

      update(dt) {
        if (this.kind === 'rapid') this.updateRapid(dt);
        else if (this.kind === 'beam') this.updateBeam(dt);
        else if (this.kind === 'wall') this.updateWall(dt);
      }

      updateRapid(dt) {
        const s = this.snapshot;
        this.cool -= dt;
        const target = nearestEnemy(this.x, this.y);
        if (!target) return;
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        this.angle = Math.atan2(dy, dx);
        if (this.cool > 0) return;
        const rof = s.fireRate;
        this.cool += 1 / rof;
        const ang = this.angle;
        const speed = 420 + s.level * 8;
        shootBulletAngle(this, ang, s.damage, speed, state.items.bounce);
      }

      updateBeam(dt) {
        const s = this.snapshot;
        this.beamSegments = [];
        const bounceStacks = state.items.bounce;
        const maxTargets = Math.min(1 + bounceStacks, state.enemies.length);
        const visited = new Set();
        let target = nearestEnemy(this.x, this.y, visited);
        if (!target) {
          this.beamTarget = null;
          this.angle = this.lastAngle;
          this.lastBeamEnemy = null;
          return;
        }
        let originX = this.x;
        let originY = this.y;
        for (let idx = 0; idx < maxTargets && target; idx += 1) {
          visited.add(target);
          const seg = { sx: originX, sy: originY, ex: target.x, ey: target.y, enemy: target };
          this.beamSegments.push(seg);
          if (idx === 0) {
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const ang = Math.atan2(dy, dx);
            this.angle = ang;
            this.lastAngle = ang;
          }
          let dmg = s.beamDPS * getBeamDpsMult() * dt;
          if (Math.random() < getCritChance()) dmg *= critMult;
          if (!target.untargetable) target.hit(dmg, this);
          applyHealFromDamage(this, dmg);
          originX = target.x;
          originY = target.y;
          target = (idx < maxTargets - 1) ? nearestEnemyTo(target, visited) : null;
        }
        if (this.beamSegments.length === 0) {
          this.beamTarget = null;
          this.angle = this.lastAngle;
          this.lastBeamEnemy = null;
          return;
        }
        this.beamTarget = this.beamSegments[0].enemy;
        this.lastBeamEnemy = this.beamSegments[this.beamSegments.length - 1].enemy;
        if (!bounceStacks) this.hasLockedDirection = true;
        if (Math.random() < 6 * dt) {
          const endSeg = this.beamSegments[this.beamSegments.length - 1];
          addParticle(endSeg.ex, endSeg.ey, '#f59e0b');
        }
      }

      updateWall(dt) {
        if (!this.isAlive()) return;
        const regen = this.snapshot.regen || 0;
        if (regen <= 0) return;
        this.hp = Math.min(this.hpMax, this.hp + regen * dt);
      }

      draw(g) {
        const deleting = state.ctrlDown && state.hoverTower === this;
        g.save();
        g.translate(this.x, this.y);
        g.rotate(this.angle);
        if (this.kind === 'rapid') {
          g.fillStyle = deleting ? '#dc2626' : '#4ea1ff';
          roundedRect(g, -14, -14, 28, 28, 8);
          g.fill();
          g.fillStyle = deleting ? '#fecaca' : '#cfe8ff';
          g.fillRect(8, -4, 14, 8);
        } else if (this.kind === 'beam') {
          g.fillStyle = deleting ? '#dc2626' : '#ffb44e';
          roundedRect(g, -13, -13, 26, 26, 8);
          g.fill();
          g.fillStyle = deleting ? '#fecaca' : '#ffe0b2';
          g.fillRect(7, -5, 14, 10);
        } else {
          g.fillStyle = deleting ? '#dc2626' : '#a1a1aa';
          roundedRect(g, -16, -16, 32, 32, 6);
          g.fill();
          g.fillStyle = deleting ? '#fecaca' : '#d4d4d8';
          g.fillRect(-6, -6, 12, 12);
        }
        g.restore();
        if (deleting) {
          g.save();
          g.strokeStyle = 'rgba(248,113,113,0.75)';
          g.lineWidth = 4;
          g.beginPath();
          g.arc(this.x, this.y, this.radius + 6, 0, Math.PI * 2);
          g.stroke();
          g.restore();
        }
        drawHpBar(g, this.x, this.y - (this.radius + 12), this.hp, this.hpMax);
        g.fillStyle = 'rgba(255,255,255,0.8)';
        g.font = '12px sans-serif';
        g.textAlign = 'center';
        let label = '';
        if (this.kind === 'rapid') label = `R L${this.snapshot.level}`;
        else if (this.kind === 'beam') label = `B L${this.snapshot.level}`;
        else label = `W L${this.snapshot.level}`;
        g.fillText(label, this.x, this.y + this.radius + 12);
      }
    }

    class Enemy {
      constructor(x, y, wave) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.wave = wave;
        const baseHP = 40 + wave * 26 + Math.pow(wave, 1.65) * 8;
        this.hpMax = baseHP;
        this.hp = this.hpMax;
        this.speed = 52 + Math.min(80, wave * 3.2);
        this.dps = 18 + wave * 3.2;
        this.alive = true;
        this.color = '#ef4444';
        this.untargetable = false;
        this.vx = 0;
        this.vy = 0;
      }

      update(dt) {
        if (!this.alive) return;
        if (this.head && !this.head.alive) return;
        const t = nearestTower(this.x, this.y);
        if (!t) {
          this.vx = 0;
          this.vy = 0;
          return;
        }
        const prevX = this.x;
        const prevY = this.y;
        const dx = t.x - this.x;
        const dy = t.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const nx = dx / d;
        const ny = dy / d;
        const contact = d <= (this.radius + t.radius);
        if (!contact) {
          this.x += nx * this.speed * dt;
          this.y += ny * this.speed * dt;
        } else {
          if (t.kind === 'wall' && t.snapshot.thorns > 0) {
            this.hit(t.snapshot.thorns * dt, t);
          }
          t.hp -= this.dps * dt;
          if (t.hp <= 0) t.hp = 0;
        }
        if (dt > 0) {
          this.vx = (this.x - prevX) / dt;
          this.vy = (this.y - prevY) / dt;
        }
      }

      hit(dmg, by) {
        if (!this.alive) return;
        this.hp -= dmg;
        if (this.hp > 0) return;
        this.alive = false;
        onEnemyKilled(this, by);
      }

      getHpBarStyle() {
        return null;
      }

      draw(g) {
        g.save();
        g.translate(this.x, this.y);
        g.fillStyle = this.color;
        g.beginPath();
        g.arc(0, 0, this.radius, 0, Math.PI * 2);
        g.fill();
        g.restore();
        drawHpBar(g, this.x, this.y - (this.radius + 10), this.hp, this.hpMax, this.getHpBarStyle() || undefined);
      }
    }

    class FastTriangle extends Enemy {
      constructor(x, y, wave) {
        super(x, y, wave);
        this.radius = 10;
        this.color = '#fb923c';
        this.speed = 120 + Math.min(140, wave * 4.2);
        this.dps *= 0.8;
        this.hpMax = this.hpMax * 0.7;
        this.hp = this.hpMax;
      }

      draw(g) {
        g.save();
        g.translate(this.x, this.y);
        const ang = Math.atan2(this.vy, this.vx);
        g.rotate(ang);
        g.fillStyle = this.color;
        g.beginPath();
        g.moveTo(14, 0);
        g.lineTo(-10, 8);
        g.lineTo(-10, -8);
        g.closePath();
        g.fill();
        g.restore();
        drawHpBar(g, this.x, this.y - (this.radius + 10), this.hp, this.hpMax);
      }
    }

    function towerNeedsUpgrade(tower) {
      if (!tower || !tower.isAlive()) return false;
      if (tower.kind === 'rapid') return tower.snapshot.level < (state.tech.rapid + 1);
      if (tower.kind === 'beam') return tower.snapshot.level < (state.tech.beam + 1);
      return false;
    }

    function pickSpiritTarget(x, y) {
      let needsUpgrade = null;
      let needsDist = Infinity;
      let fallback = null;
      let fallbackDist = Infinity;
      for (const tower of state.towers) {
        if (!tower.isAlive()) continue;
        const d = Math.hypot(tower.x - x, tower.y - y);
        if (towerNeedsUpgrade(tower)) {
          if (d < needsDist) {
            needsDist = d;
            needsUpgrade = tower;
          }
        } else if (d < fallbackDist) {
          fallbackDist = d;
          fallback = tower;
        }
      }
      return needsUpgrade || fallback;
    }

    class Spirit extends Enemy {
      constructor(x, y, wave) {
        super(x, y, wave);
        this.color = '#38bdf8';
        this.radius = 10;
        this.speed = 82 + Math.min(120, wave * 3.8);
        this.untargetable = true;
        this.invulnerable = true;
        this.infused = false;
        this.targetTower = null;
      }

      hit(dmg, by) { /* ignore damage */ }

      update(dt) {
        if (!this.alive || this.infused) return;
        const t = pickSpiritTarget(this.x, this.y);
        this.targetTower = t;
        if (!t) {
          this.vx = 0;
          this.vy = 0;
          return;
        }
        const prevX = this.x;
        const prevY = this.y;
        const dx = t.x - this.x;
        const dy = t.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const nx = dx / d;
        const ny = dy / d;
        const contact = d <= (this.radius + t.radius + 2);
        if (!contact) {
          this.x += nx * this.speed * dt;
          this.y += ny * this.speed * dt;
        } else {
          this.infuse(t);
        }
        if (dt > 0) {
          this.vx = (this.x - prevX) / dt;
          this.vy = (this.y - prevY) / dt;
        }
      }

      infuse(primary) {
        if (this.infused) return;
        this.infused = true;
        this.alive = false;
        this.hp = 0;
        const radius = 120;
        const cx = primary ? primary.x : this.x;
        const cy = primary ? primary.y : this.y;
        addRing(cx, cy, radius);
        let affected = 0;
        for (const tw of state.towers) {
          if (!tw.isAlive()) continue;
          const dist = Math.hypot(tw.x - cx, tw.y - cy);
          if (dist > radius) continue;
          affected += 1;
          if (tw.kind === 'rapid') {
            const targetLvl = state.tech.rapid + 1;
            if (tw.snapshot.level < targetLvl) tw.snapshot = computeRapidStats(targetLvl);
          } else if (tw.kind === 'beam') {
            const targetLvl = state.tech.beam + 1;
            if (tw.snapshot.level < targetLvl) tw.snapshot = computeBeamStats(targetLvl);
          }
          tw.hp = Math.min(tw.hpMax, tw.hp + tw.hpMax * 0.4);
          tw.cool = 0;
        }
        if (affected > 0) pushToast('Spirit infusion!', cx, cy - 40);
      }

      draw(g) {
        super.draw(g);
        g.save();
        g.globalAlpha = 0.35;
        g.strokeStyle = '#38bdf8';
        g.lineWidth = 2;
        g.beginPath();
        g.arc(this.x, this.y, this.radius + 6, 0, Math.PI * 2);
        g.stroke();
        g.restore();
      }
    }

    class WormHead extends Enemy {
      constructor(x, y, wave, segmentCount) {
        super(x, y, wave);
        this.radius = 18;
        this.color = '#dc2626';
        this.speed = 52 + Math.min(60, wave * 2.2);
        this.hpMax = this.hpMax * 10;
        this.hp = this.hpMax;
        this.dps *= 1.4;
        this.segmentCount = segmentCount;
        this.leadingSpacing = 60;
        this.segmentSpacing = 40;
        this.trail = [];
        this.maxTrail = Math.max(220, this.leadingSpacing + (segmentCount + 6) * this.segmentSpacing);
        this.segments = [];
        this.contacting = false;
      }

      attachSegments(segments) {
        this.segments = segments;
        this.trail = [];
        const seedLength = this.maxTrail;
        for (let i = 0; i < seedLength; i += 1) {
          this.trail.push({ x: this.x - i * 2, y: this.y });
        }
        this.compactSegments();
      }

      update(dt) {
        if (!this.alive) return;
        super.update(dt);
        this.trail.unshift({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) this.trail.pop();
        const tower = nearestTower(this.x, this.y);
        const contact = tower && Math.hypot(tower.x - this.x, tower.y - this.y) <= (this.radius + tower.radius + 0.5);
        this.contacting = !!contact;
        if (this.contacting) {
          for (const entry of this.trail) {
            entry.x = this.x;
            entry.y = this.y;
          }
        }
      }

      getTrailPoint(distance) {
        if (this.trail.length === 0) return { x: this.x, y: this.y };
        const idx = clamp(Math.round(distance), 0, this.trail.length - 1);
        return this.trail[idx];
      }

      compactSegments() {
        for (let i = 0; i < this.segments.length; i += 1) {
          const seg = this.segments[i];
          if (!seg.alive) continue;
          seg.index = i;
          seg.followDistance = this.leadingSpacing + i * this.segmentSpacing;
          const pos = this.getTrailPoint(seg.followDistance);
          if (pos) {
            seg.x = pos.x;
            seg.y = pos.y;
          }
        }
      }

      onSegmentDestroyed(seg) {
        const idx = this.segments.indexOf(seg);
        if (idx !== -1) this.segments.splice(idx, 1);
        this.compactSegments();
      }

      hit(dmg, by) {
        if (this.segments.some((seg) => seg.alive)) return;
        super.hit(dmg, by);
      }

      getHpBarStyle() {
        return { background: 'rgba(248,113,113,0.35)', fill: '#7ee787', width: 48, height: 6 };
      }

      draw(g) {
        super.draw(g);
        if (this.segments.some((seg) => seg.alive)) {
          g.save();
          g.globalAlpha = 0.25;
          g.strokeStyle = '#f87171';
          g.lineWidth = 3;
          g.beginPath();
          g.arc(this.x, this.y, this.radius + 12, 0, Math.PI * 2);
          g.stroke();
          g.restore();
        }
      }
    }

    class WormSegment extends Enemy {
      constructor(head, index) {
        super(head.x, head.y, head.wave);
        this.head = head;
        this.index = index;
        const leading = head.leadingSpacing || head.segmentSpacing;
        this.followDistance = leading + index * head.segmentSpacing;
        this.radius = 14;
        this.color = '#f97316';
        this.speed = head.speed * 0.9;
        this.dps *= 0.9;
        this.hpMax = this.hpMax * 0.8;
        this.hp = this.hpMax;
        this.frozenOffset = null;
      }

      update(dt) {
        if (!this.alive) return;
        const prevX = this.x;
        const prevY = this.y;
        if (this.head && this.head.contacting) {
          if (!this.frozenOffset) {
            this.frozenOffset = { dx: this.x - this.head.x, dy: this.y - this.head.y };
          }
          this.x = this.head.x + this.frozenOffset.dx;
          this.y = this.head.y + this.frozenOffset.dy;
          this.vx = 0;
          this.vy = 0;
          return;
        }
        this.frozenOffset = null;
        const targetPos = this.head.getTrailPoint(this.followDistance);
        this.x = targetPos.x;
        this.y = targetPos.y;
        if (dt > 0) {
          this.vx = (this.x - prevX) / dt;
          this.vy = (this.y - prevY) / dt;
        }
        const t = (this.head && this.head.contacting) ? null : nearestTower(this.x, this.y);
        if (!t) return;
        const dxT = t.x - this.x;
        const dyT = t.y - this.y;
        const dT = Math.hypot(dxT, dyT) || 1;
        if (dT <= (this.radius + t.radius)) {
          t.hp -= this.dps * dt;
          if (t.hp <= 0) t.hp = 0;
        }
      }

      hit(dmg, by) {
        if (!this.alive) return;
        super.hit(dmg, by);
        if (!this.alive) {
          for (let i = 0; i < 6; i += 1) addParticle(this.x, this.y, '#fb7185');
          addRing(this.x, this.y, 22);
          this.head.onSegmentDestroyed(this);
        }
      }

      getHpBarStyle() {
        return { background: 'rgba(248,113,113,0.45)', fill: '#90f0a5', width: 48, height: 6 };
      }

      draw(g) {
        super.draw(g);
      }
    }

    class Projectile {
      constructor(x, y, vx, vy, dmg, bounces = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.dmg = dmg;
        this.r = 4;
        this.alive = true;
        this.bounces = bounces;
        this.lastHit = null;
        this.owner = null;
      }

      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        for (const e of state.enemies) {
          if (!e.alive || e.untargetable) continue;
          const r = e.radius + this.r;
          const d2v = (e.x - this.x) * (e.x - this.x) + (e.y - this.y) * (e.y - this.y);
          if (d2v > r * r) continue;
          let dmg = this.dmg;
          if (Math.random() < getCritChance()) dmg *= critMult;
          e.hit(dmg, this.owner);
          applyHealFromDamage(this.owner, dmg);
          if (this.bounces > 0) {
            const speed = Math.hypot(this.vx, this.vy) || 0.01;
            const target = nearestEnemyExcept(e, this.x, this.y);
            let ang;
            if (target) {
              const lead = computeLeadPoint(this.x, this.y, speed, target);
              ang = Math.atan2(lead.y - this.y, lead.x - this.x);
            } else {
              ang = Math.random() * Math.PI * 2;
            }
            this.vx = Math.cos(ang) * speed;
            this.vy = Math.sin(ang) * speed;
            this.bounces -= 1;
            this.dmg *= 0.7;
            this.lastHit = e;
            continue;
          }
          this.alive = false;
          break;
        }
        if (this.x < -60 || this.y < -60 || this.x > state.width + 60 || this.y > state.height + 60) {
          this.alive = false;
        }
      }

      draw(g) {
        g.fillStyle = '#b6d7ff';
        g.beginPath();
        g.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        g.fill();
      }
    }

    function shootBulletAngle(tower, ang, dmg, speed, bounces) {
      const vx = Math.cos(ang) * speed;
      const vy = Math.sin(ang) * speed;
      const p = new Projectile(tower.x + Math.cos(ang) * 18, tower.y + Math.sin(ang) * 18, vx, vy, dmg, bounces);
      p.owner = tower;
      state.projectiles.push(p);
    }

    function enemyPriority(entity) {
      if (entity instanceof WormSegment) return 0;
      if (entity instanceof WormHead) return 1;
      return 2;
    }

    function nearestEnemy(x, y, skipSet) {
      let best = null;
      let bestPriority = Infinity;
      let bd = Infinity;
      for (const e of state.enemies) {
        if (!e.alive || e.untargetable) continue;
        if (skipSet && skipSet.has(e)) continue;
        const pri = enemyPriority(e);
        const d = dist2({ x, y }, e);
        if (pri < bestPriority || (pri === bestPriority && d < bd)) {
          bestPriority = pri;
          bd = d;
          best = e;
        }
      }
      return best;
    }

    function nearestEnemyExcept(ex, x, y) {
      let best = null;
      let bestPriority = Infinity;
      let bd = Infinity;
      for (const e of state.enemies) {
        if (e === ex || !e.alive || e.untargetable) continue;
        const pri = enemyPriority(e);
        const d = dist2({ x, y }, e);
        if (pri < bestPriority || (pri === bestPriority && d < bd)) {
          bestPriority = pri;
          bd = d;
          best = e;
        }
      }
      return best;
    }

    function nearestEnemyTo(ref, visitedSet) {
      if (!ref) return null;
      let best = null;
      let bestPriority = Infinity;
      let bd = Infinity;
      for (const e of state.enemies) {
        if (!e.alive || e.untargetable || e === ref) continue;
        if (visitedSet && visitedSet.has(e)) continue;
        const pri = enemyPriority(e);
        const d = dist2(ref, e);
        if (pri < bestPriority || (pri === bestPriority && d < bd)) {
          bestPriority = pri;
          bd = d;
          best = e;
        }
      }
      return best;
    }

    function nearestTower(x, y) {
      let best = null;
      let bd = Infinity;
      for (const t of state.towers) {
        if (!t.isAlive()) continue;
        const d = dist2({ x, y }, t);
        if (d < bd) {
          bd = d;
          best = t;
        }
      }
      return best;
    }

    function towerUnderPoint(x, y) {
      let best = null;
      let bestDist = Infinity;
      for (const t of state.towers) {
        if (!t.isAlive()) continue;
        const d = Math.hypot(t.x - x, t.y - y);
        if (d <= t.radius + 4 && d < bestDist) {
          best = t;
          bestDist = d;
        }
      }
      return best;
    }

    // Particles and effects
    function addParticle(x, y, color) {
      state.particles.push({ x, y, vx: rand(-40, 40), vy: rand(-40, 40), life: rand(0.3, 0.7), color });
    }

    function updateParticles(dt) {
      for (const p of state.particles) {
        p.life -= dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
      state.particles = state.particles.filter((p) => p.life > 0);
    }

    function drawParticles(g) {
      for (const p of state.particles) {
        g.globalAlpha = Math.max(0, p.life * 1.5);
        g.fillStyle = p.color;
        g.fillRect(p.x - 1, p.y - 1, 2, 2);
        g.globalAlpha = 1;
      }
    }

    function addRing(x, y, r) {
      state.rings.push({ x, y, r, life: 0.5 });
    }

    function updateRings(dt) {
      for (const ring of state.rings) {
        ring.life -= dt;
      }
      state.rings = state.rings.filter((r) => r.life > 0);
    }

    function drawRings(g) {
      for (const ring of state.rings) {
        const a = clamp(ring.life / 0.5, 0, 1);
        ctx.save();
        ctx.globalAlpha = a * 0.8;
        ctx.strokeStyle = '#fde047';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = a * 0.6;
        ctx.strokeStyle = '#facc15';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ring.x, ring.y, ring.r * 0.86, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    // Tech snapshot calculators
    function computeRapidStats(level) {
      return { level, damage: 8 + (level - 1) * 2.0, fireRate: 6 + (level - 1) * 0.5 };
    }

    function computeBeamStats(level) {
      return { level, beamDPS: 42 + (level - 1) * 10, beamWidth: 6 + (level - 1) * 0.7 };
    }

    function computeWallStats(level) {
      const lvl = Math.max(1, level || 1);
      const hpMax = Math.floor(520 + (lvl - 1) * 90);
      const thorns = 4 + (lvl - 1) * 1.6;
      const regen = 6 + (lvl - 1) * 1.4;
      return { level: lvl, hpMax, thorns, regen };
    }

    // Items
    const itemKeys = ['crit', 'bounce', 'hp', 'lifesteal'];

    function onItemGained(key) {
      if (!(key in state.items)) return false;
      state.items[key] += 1;
      if (key === 'hp') {
        for (const t of state.towers) {
          const oldMax = t.hpMax;
          t.hpMax = t.baseHpMax * (1 + 0.10 * state.items.hp);
          if (oldMax > 0) {
            t.hp = Math.min(t.hp * (t.hpMax / oldMax), t.hpMax);
          }
        }
      }
      addParticle(rand(40, state.width - 40), rand(40, state.height - 40), '#a7f3d0');
      return true;
    }

    function onEnemyKilled(enemy, by) {
      state.xp += 1;
      if (Math.random() < state.dropChance) {
        const key = itemKeys[Math.floor(Math.random() * itemKeys.length)];
        spawnDrop(key, enemy.x, enemy.y);
      }
      addParticle(enemy.x, enemy.y, '#ff7777');
    }

    // Waves and spawning
    function startWave() {
      const nextWave = state.wave + 1;
      const count = Math.floor(6 + nextWave * 4 + Math.pow(nextWave, 1.35));
      state.wave = nextWave;
      state.spawning = true;
      state.spawnCooldown = 0;
      state.spawnedThisWave = 0;
      state.bossSpawned = false;
      state.nextWaveQueued = false;
      state.enemiesToSpawn += count;
      if (state.wave % 5 === 0) spawnBoss();
    }

    function spawnBoss() {
      const m = 24;
      const side = Math.floor(Math.random() * 4);
      let x;
      let y;
      if (side === 0) { x = rand(-m, state.width + m); y = -m; }
      else if (side === 1) { x = state.width + m; y = rand(-m, state.height + m); }
      else if (side === 2) { x = rand(-m, state.width + m); y = state.height + m; }
      else { x = -m; y = rand(-m, state.height + m); }
      const segmentCount = Math.min(6, 3 + Math.floor(state.wave / 5));
      const head = new WormHead(x, y, state.wave, segmentCount);
      state.enemies.push(head);
      const segments = [];
      for (let i = 0; i < segmentCount; i += 1) {
        const seg = new WormSegment(head, i);
        segments.push(seg);
        state.enemies.push(seg);
      }
      head.attachSegments(segments);
      state.bossSpawned = true;
    }

    function endRound(reason = 'Round Over') {
      autoCollectDrops();
      overlay.hidden = false;
      overlayTitle.textContent = reason;
      overlayBody.textContent = 'All towers were destroyed.';
      finalWaveEl.textContent = `Wave: ${state.wave}`;
      finalXPEl.textContent = `XP: ${state.xp}`;
      state.running = false;
    }

    function reset(full = true) {
      state.towers = [];
      state.enemies = [];
      state.projectiles = [];
      state.particles = [];
      state.rings = [];
      state.drops = [];
      state.toasts = [];
      state.wave = 0;
      state.spawning = false;
      state.enemiesToSpawn = 0;
      state.spawnCooldown = 0;
      state.firstPlaced = false;
      state.nextWaveQueued = false;
      state.spawnedThisWave = 0;
      state.bossSpawned = false;
      if (full) {
        state.xp = 0;
        state.items = { crit: 0, bounce: 0, hp: 0, lifesteal: 0 };
      }
      state.running = true;
      overlay.hidden = true;
      state.hoverTower = null;
      state.ctrlDown = false;
    }

    function spawnEnemy() {
      if (state.enemiesToSpawn <= 0) return;
      state.spawnedThisWave += 1;
      const m = 24;
      const side = Math.floor(Math.random() * 4);
      let x;
      let y;
      if (side === 0) { x = rand(-m, state.width + m); y = -m; }
      else if (side === 1) { x = state.width + m; y = rand(-m, state.height + m); }
      else if (side === 2) { x = rand(-m, state.width + m); y = state.height + m; }
      else { x = -m; y = rand(-m, state.height + m); }
      if (Math.random() < 0.2) state.enemies.push(new FastTriangle(x, y, state.wave));
      else state.enemies.push(new Enemy(x, y, state.wave));
    }

    function summonSpirit() {
      const aliveTowers = state.towers.filter((t) => t.isAlive());
      if (aliveTowers.length === 0) return false;
      const m = 24;
      const side = Math.floor(Math.random() * 4);
      let x;
      let y;
      if (side === 0) { x = rand(-m, state.width + m); y = -m; }
      else if (side === 1) { x = state.width + m; y = rand(-m, state.height + m); }
      else if (side === 2) { x = rand(-m, state.width + m); y = state.height + m; }
      else { x = -m; y = rand(-m, state.height + m); }
      const waveLevel = Math.max(1, state.wave || 1);
      const spirit = new Spirit(x, y, waveLevel);
      spirit.playerSummoned = true;
      state.enemies.push(spirit);
      pushToast('Spirit summoned', state.width / 2, 60);
      return true;
    }

    function towerRadius(kind) {
      if (kind === 'rapid') return 14;
      if (kind === 'beam') return 13;
      if (kind === 'wall') return 16;
      return 16;
    }

    function getPlacementInfo(kind, rawX, rawY) {
      const radius = towerRadius(kind);
      let x = rawX;
      let y = rawY;
      if (state.gridSnap) {
        const snap = (v) => Math.round(v / GRID_SIZE) * GRID_SIZE;
        x = snap(x);
        y = snap(y);
        const pad = radius + 6;
        x = clamp(x, pad, state.width - pad);
        y = clamp(y, pad, state.height - pad);
      }
      let blocked = false;
      for (const t of state.towers) {
        if (!t.isAlive()) continue;
        const minDist = t.radius + radius + 6;
        if (Math.hypot(x - t.x, y - t.y) < minDist) {
          blocked = true;
          break;
        }
      }
      const cost = state.costs[kind];
      const hasCost = typeof cost === 'number' && Number.isFinite(cost);
      const affordable = hasCost && (!state.firstPlaced || state.xp >= cost);
      const placeable = affordable && !blocked;
      return { x, y, radius, blocked, affordable, placeable };
    }

    function tryPlace(kind, rawX, rawY) {
      const info = getPlacementInfo(kind, rawX, rawY);
      if (!info.placeable) return false;
      const cost = state.costs[kind];
      if (typeof cost !== 'number') return false;
      let snapshot;
      if (kind === 'rapid') snapshot = computeRapidStats(state.tech.rapid);
      else if (kind === 'beam') snapshot = computeBeamStats(state.tech.beam);
      else snapshot = computeWallStats(state.tech.wall);
      const t = new Tower(info.x, info.y, kind, snapshot);
      state.towers.push(t);
      if (state.firstPlaced) state.xp -= cost;
      else state.firstPlaced = true;
      if (state.wave === 0) startWave();
      return true;
    }

    // Input handling
    const mouse = { x: 0, y: 0 };
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = state.width / canvas.clientWidth;
      const scaleY = state.height / canvas.clientHeight;
      mouse.x = (e.clientX - rect.left) * scaleX;
      mouse.y = (e.clientY - rect.top) * scaleY;
      state.hoverTower = towerUnderPoint(mouse.x, mouse.y);
      state.ctrlDown = e.ctrlKey;
    });
    function deleteTowerUnderCursor() {
      const target = towerUnderPoint(mouse.x, mouse.y);
      if (!target) return false;
      const idx = state.towers.indexOf(target);
      if (idx !== -1) state.towers.splice(idx, 1);
      target.hp = 0;
      state.hoverTower = towerUnderPoint(mouse.x, mouse.y);
      return true;
    }

    canvas.addEventListener('click', (e) => {
      const ctrl = e.ctrlKey || state.ctrlDown;
      if (ctrl) {
        deleteTowerUnderCursor();
        return;
      }
      if (!state.running) return;
      tryPlace(state.selected, mouse.x, mouse.y);
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === '1') state.selected = 'rapid';
      else if (e.key === '2') state.selected = 'beam';
      else if (e.key === '3') state.selected = 'wall';
      else if (e.key === ' ') state.running = !state.running;
      else if (e.key === 'r' || e.key === 'R') reset(true);
      else if (e.key === 'g' || e.key === 'G') state.gridSnap = !state.gridSnap;
      else if (e.key === 'n' || e.key === 'N') {
        if (!state.running) return;
        if (!state.firstPlaced) return;
        if (!state.towers.some((t) => t.isAlive())) return;
        if (state.spawning && state.enemiesToSpawn > 0) {
          while (state.enemiesToSpawn > 0) {
            spawnEnemy();
            state.enemiesToSpawn -= 1;
          }
          state.spawning = false;
        }
        startWave();
      }
      state.ctrlDown = e.ctrlKey;
    });
    btnRapid.addEventListener('click', () => { state.selected = 'rapid'; });
    btnBeam.addEventListener('click', () => { state.selected = 'beam'; });
    if (btnWall) btnWall.addEventListener('click', () => { state.selected = 'wall'; });
    btnRestart.addEventListener('click', () => reset(true));
    document.addEventListener('keyup', (e) => {
      if (!e.ctrlKey) state.ctrlDown = false;
    });

    buyRapidBtn.addEventListener('click', () => {
      const cost = techCost('rapid');
      if (state.xp >= cost) {
        state.xp -= cost;
        state.tech.rapid += 1;
      }
    });

    buyBeamBtn.addEventListener('click', () => {
      const cost = techCost('beam');
      if (state.xp >= cost) {
        state.xp -= cost;
        state.tech.beam += 1;
      }
    });

    if (buyWallBtn) {
      buyWallBtn.addEventListener('click', () => {
        const cost = techCost('wall');
        if (state.xp >= cost) {
          state.xp -= cost;
          state.tech.wall += 1;
        }
      });
    }

    if (toggleSnapBtn) {
      toggleSnapBtn.addEventListener('click', () => {
        state.gridSnap = !state.gridSnap;
      });
    }

    if (spiritBtn) {
      spiritBtn.addEventListener('click', () => {
        if (!state.running || !state.firstPlaced) return;
        if (state.xp < SPIRIT_COST) return;
        if (!state.towers.some((t) => t.isAlive())) return;
        if (summonSpirit()) {
          state.xp -= SPIRIT_COST;
        }
      });
    }

    function techCost(kind) {
      if (kind === 'rapid') return Math.floor(6 + (state.tech.rapid - 1) * 4);
      if (kind === 'beam') return Math.floor(10 + (state.tech.beam - 1) * 6);
      if (kind === 'wall') return Math.floor(8 + (state.tech.wall - 1) * 5);
      return Infinity;
    }

    // Main loop
    function loop(ts) {
      if (!state.last) state.last = ts;
      state.dt = Math.min(0.033, (ts - state.last) / 1000);
      state.last = ts;
      if (state.running) update(state.dt);
      else updateToasts(state.dt);
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      state.time += dt;
      if (state.spawning) {
        state.spawnCooldown -= dt;
        if (state.spawnCooldown <= 0 && state.enemiesToSpawn > 0) {
          spawnEnemy();
          state.enemiesToSpawn -= 1;
          state.spawnCooldown = 0.55 - Math.min(0.35, state.wave * 0.012);
        }
        if (state.enemiesToSpawn <= 0) state.spawning = false;
      } else if (state.wave > 0 && !state.nextWaveQueued && state.enemies.every((e) => !e.alive)) {
        state.nextWaveQueued = true;
        autoCollectDrops();
        setTimeout(() => {
          if (state.running) startWave();
        }, 1500);
      }

      for (const t of state.towers) if (t.isAlive()) t.update(dt);
      for (const e of state.enemies) e.update(dt);
      state.enemies = state.enemies.filter((e) => e.alive || e.hp > 0);
      for (const p of state.projectiles) p.update(dt);
      state.projectiles = state.projectiles.filter((p) => p.alive);
      updateDrops(dt);
      const livingTowers = state.towers.filter((t) => t.isAlive());
      if (state.firstPlaced && livingTowers.length === 0) endRound('Round Over');
      updateParticles(dt);
      updateRings(dt);
      updateToasts(dt);

      // UI sync
      waveEl.textContent = state.wave.toString();
      xpEl.textContent = state.xp.toString();
      towerCountEl.textContent = livingTowers.length.toString();
      enemyCountEl.textContent = state.enemies.filter((e) => e.alive).length.toString();
      rapidLvlEl.textContent = `Lv.${state.tech.rapid}`;
      beamLvlEl.textContent = `Lv.${state.tech.beam}`;
      if (wallLvlEl) wallLvlEl.textContent = `Lv.${state.tech.wall}`;
      rapidCostEl.textContent = `Cost: ${techCost('rapid')} XP`;
      beamCostEl.textContent = `Cost: ${techCost('beam')} XP`;
      if (wallCostEl) wallCostEl.textContent = `Cost: ${techCost('wall')} XP`;
      costRapidEl.textContent = `${state.costs.rapid} XP`;
      costBeamEl.textContent = `${state.costs.beam} XP`;
      if (costWallEl) costWallEl.textContent = `${state.costs.wall} XP`;
      const canRapidUpgrade = state.xp >= techCost('rapid');
      const canBeamUpgrade = state.xp >= techCost('beam');
      const canWallUpgrade = state.xp >= techCost('wall');
      buyRapidBtn.disabled = !canRapidUpgrade;
      buyRapidBtn.classList.toggle('can-upgrade', canRapidUpgrade);
      buyBeamBtn.disabled = !canBeamUpgrade;
      buyBeamBtn.classList.toggle('can-upgrade', canBeamUpgrade);
      if (buyWallBtn) {
        buyWallBtn.disabled = !canWallUpgrade;
        buyWallBtn.classList.toggle('can-upgrade', canWallUpgrade);
      }
      const sr = computeRapidStats(state.tech.rapid);
      const sb = computeBeamStats(state.tech.beam);
      const sw = computeWallStats(state.tech.wall);
      if (statsRapidEl) statsRapidEl.textContent = `DMG ${sr.damage}\nROF ${sr.fireRate.toFixed(1)}/s`;
      if (statsBeamEl) statsBeamEl.textContent = `DPS ${sb.beamDPS}\nWidth ${(sb.beamWidth + getBeamWidthBonus()).toFixed(1)}`;
      if (statsWallEl) {
        const wallHp = Math.round(sw.hpMax * (1 + 0.10 * state.items.hp));
        statsWallEl.textContent = `HP ${wallHp}\nThorns ${sw.thorns.toFixed(1)}/s\nRegen ${sw.regen.toFixed(1)}/s`;
      }
      itmCritEl.textContent = `x${state.items.crit}`;
      itmBncEl.textContent = `x${state.items.bounce}`;
      itmHPEl.textContent = `x${state.items.hp}`;
      itmLSEl.textContent = `x${state.items.lifesteal}`;
      btnRapid.style.opacity = (!state.firstPlaced || state.xp >= state.costs.rapid) ? 1 : 0.5;
      btnBeam.style.opacity = (!state.firstPlaced || state.xp >= state.costs.beam) ? 1 : 0.5;
      if (btnWall) btnWall.style.opacity = (!state.firstPlaced || state.xp >= state.costs.wall) ? 1 : 0.5;
      if (toggleSnapBtn) {
        toggleSnapBtn.textContent = state.gridSnap ? 'Grid Snap: On' : 'Grid Snap: Off';
        toggleSnapBtn.classList.toggle('can-upgrade', state.gridSnap);
      }
      if (spiritCostEl) spiritCostEl.textContent = `Cost: ${SPIRIT_COST} XP`;
      if (spiritBtn) {
        const canSpirit = state.firstPlaced && state.xp >= SPIRIT_COST && livingTowers.length > 0;
        spiritBtn.disabled = !canSpirit;
        spiritBtn.classList.toggle('can-upgrade', canSpirit);
      }
    }

    function drawGrid(g) {
      g.save();
      g.strokeStyle = 'rgba(255,255,255,0.05)';
      g.lineWidth = 1;
      for (let x = 0; x < state.width; x += GRID_SIZE) {
        g.beginPath();
        g.moveTo(x, 0);
        g.lineTo(x, state.height);
        g.stroke();
      }
      for (let y = 0; y < state.height; y += GRID_SIZE) {
        g.beginPath();
        g.moveTo(0, y);
        g.lineTo(state.width, y);
        g.stroke();
      }
      g.restore();
    }

    function draw() {
      state.hoverTower = towerUnderPoint(mouse.x, mouse.y);
      ctx.clearRect(0, 0, state.width, state.height);
      drawGrid(ctx);
      for (const t of state.towers) if (t.kind === 'beam' && t.isAlive()) drawBeamPath(t);
      drawDrops(ctx);
      for (const p of state.projectiles) p.draw(ctx);
      for (const t of state.towers) if (t.isAlive()) t.draw(ctx);
      for (const e of state.enemies) if (e.alive) e.draw(ctx);
      drawParticles(ctx);
      drawRings(ctx);
      drawToasts(ctx);
      if (state.running) drawGhost();
    }

    function drawBeamPath(t) {
      if (!t.beamSegments || t.beamSegments.length === 0) return;
      const s = t.snapshot;
      const widthOuter = Math.max(2, (s.beamWidth + getBeamWidthBonus()) * 0.8);
      const widthInner = Math.max(1, (s.beamWidth + getBeamWidthBonus()) * 0.45);
      ctx.save();
      ctx.strokeStyle = 'rgba(255,200,120,0.35)';
      ctx.lineWidth = widthOuter;
      ctx.beginPath();
      ctx.moveTo(t.beamSegments[0].sx, t.beamSegments[0].sy);
      for (const seg of t.beamSegments) {
        ctx.lineTo(seg.ex, seg.ey);
      }
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,170,80,0.75)';
      ctx.lineWidth = widthInner;
      ctx.beginPath();
      ctx.moveTo(t.beamSegments[0].sx, t.beamSegments[0].sy);
      for (const seg of t.beamSegments) {
        ctx.lineTo(seg.ex, seg.ey);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawGhost() {
      const kind = state.selected;
      const info = getPlacementInfo(kind, mouse.x, mouse.y);
      ctx.save();
      if (info.placeable) {
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = kind === 'rapid' ? '#63b4ff' : (kind === 'beam' ? '#ffc976' : '#b0b5bf');
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 14;
      } else {
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = 'rgba(148, 163, 184, 0.85)';
      }
      ctx.beginPath();
      ctx.arc(info.x, info.y, info.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Sanity tests (console)
    function runSanityTests() {
      const errors = [];
      const backup = {
        enemies: state.enemies.slice(),
        towers: state.towers.slice(),
        tech: { ...state.tech },
        items: { ...state.items },
        wave: state.wave,
        enToSpawn: state.enemiesToSpawn,
        spc: state.spawnedThisWave,
        drops: state.drops.slice(),
        toasts: state.toasts.slice(),
      };
      try {
        state.enemies = [];
        if (nearestEnemy(0, 0) !== null) errors.push('nearestEnemy should return null when empty');
        const eNear = new Enemy(10, 0, 1);
        eNear.untargetable = true;
        const eFar = new Enemy(300, 300, 1);
        state.enemies = [eNear, eFar];
        if (nearestEnemy(0, 0) !== eFar) errors.push('nearestEnemy must ignore untargetable enemies');
        state.tech.rapid = 3;
        const tw = new Tower(0, 0, 'rapid', computeRapidStats(1));
        const twBeam = new Tower(40, 0, 'beam', computeBeamStats(1));
        state.towers = [tw, twBeam];
        state.tech.wall = 2;
        const wallStats1 = computeWallStats(1);
        const wallStats2 = computeWallStats(state.tech.wall);
        if (wallStats2.hpMax <= wallStats1.hpMax) errors.push('Wall HP should scale with tech level');
        if (wallStats1.thorns <= 0 || wallStats2.thorns <= wallStats1.thorns) errors.push('Wall thorns should increase with tech');
        const wallTower = new Tower(0, 0, 'wall', computeWallStats(1));
        wallTower.hp = wallTower.hpMax * 0.5;
        wallTower.update(1);
        if (wallTower.hp <= wallTower.hpMax * 0.5) errors.push('Wall regen should restore HP over time');
        const lifestealBackup = state.items.lifesteal;
        state.items.lifesteal = 5;
        const wallHealTest = new Tower(0, 0, 'wall', computeWallStats(1));
        const wallHealBaseline = wallHealTest.hp = wallHealTest.hpMax * 0.4;
        applyHealFromDamage(wallHealTest, 200);
        if (Math.abs(wallHealTest.hp - wallHealBaseline) > 0.001) errors.push('Lifesteal should not affect walls');
        state.items.lifesteal = lifestealBackup;
        tw.hp = tw.hpMax * 0.3;
        twBeam.hp = twBeam.hpMax * 0.2;
        const spirit = new Spirit(0, 0, 1);
        spirit.infuse(tw);
        const expectedLvl = state.tech.rapid + 1;
        if (tw.snapshot.level !== expectedLvl) errors.push('Spirit infusion should set tower level to tech+1');
        if (twBeam.snapshot.level <= state.tech.beam) errors.push('Spirit infusion should upgrade nearby beam towers');
        if (tw.hp <= tw.hpMax * 0.3 || twBeam.hp <= twBeam.hpMax * 0.2) errors.push('Spirit infusion should restore tower HP');
        if (spirit.alive) errors.push('Spirit should vanish after infusing');
        state.wave = 2;
        state.spawning = true;
        state.enemiesToSpawn = 1;
        state.spawnedThisWave = 0;
        const oldRand = Math.random;
        Math.random = () => 0;
        spawnEnemy();
        if (!(state.enemies[state.enemies.length - 1] instanceof FastTriangle)) errors.push('spawnEnemy should enqueue FastTriangle on low roll');
        state.enemies = [];
        Math.random = () => 0.99;
        spawnEnemy();
        if (!(state.enemies[state.enemies.length - 1] instanceof Enemy)) errors.push('spawnEnemy should enqueue standard enemy on high roll');
        Math.random = oldRand;
        state.enemies = [];
        state.towers = [];
        if (summonSpirit()) errors.push('summonSpirit should fail without towers');
        state.towers = [tw];
        state.wave = 3;
        const spiritSpawned = summonSpirit();
        if (!spiritSpawned) errors.push('summonSpirit should spawn when towers exist');
        else if (!(state.enemies[state.enemies.length - 1] instanceof Spirit)) errors.push('summonSpirit should spawn a Spirit');
        state.enemies = [];
        state.wave = 4;
        startWave();
        const hasHead = state.enemies.some((e) => e instanceof WormHead);
        const hasSegment = state.enemies.some((e) => e instanceof WormSegment);
        if (!hasHead || !hasSegment) errors.push('Worm boss should spawn head and segments on boss wave');
        const head = state.enemies.find((e) => e instanceof WormHead);
        if (head) {
          const testSeg = head.segments.find((seg) => seg && seg.alive && seg.hp > 1);
          if (testSeg) {
            const hpBefore = testSeg.hp;
            const dmgSample = Math.min(Math.max(1, hpBefore * 0.1), hpBefore - 1);
            testSeg.hit(dmgSample, null);
            if (!(testSeg.hp < hpBefore)) errors.push('Worm segment should lose HP when damaged');
            testSeg.hp = hpBefore;
            testSeg.alive = true;
          }
          const originalCount = head.segments.length;
          if (originalCount > 1) {
            const mid = head.segments[Math.floor(originalCount / 2)];
            const prevPos = { x: mid.x, y: mid.y };
            mid.hit(mid.hpMax + 1, null);
            if (head.segments.length !== originalCount - 1) errors.push('Segment removal should compact worm body');
            const nextSeg = head.segments[Math.min(Math.floor(originalCount / 2), head.segments.length - 1)];
            if (nextSeg && Math.hypot(nextSeg.x - prevPos.x, nextSeg.y - prevPos.y) > 24) {
              errors.push('Worm segments should snap into place after a segment is destroyed');
            }
          }
          head.hit(head.hpMax * 2, null);
          if (!head.alive && head.segments.some((seg) => seg.alive)) errors.push('Worm head should withstand damage while segments live');
          head.segments.slice().forEach((seg) => seg.hit(seg.hpMax + 1, null));
          head.hit(head.hpMax * 2, null);
          if (head.alive) errors.push('Worm head should fall once segments are gone');
        }
        const headPriority = new WormHead(0, 0, 5, 1);
        const segPriority = new WormSegment(headPriority, 0);
        headPriority.attachSegments([segPriority]);
        state.enemies = [headPriority, segPriority];
        const preferSeg = nearestEnemy(10, 0);
        if (!(preferSeg instanceof WormSegment)) errors.push('Targeting should prioritise worm body segments over head');
      } catch (err) {
        console.error('Sanity test runtime error:', err);
        errors.push('Runtime error during tests.');
      } finally {
        state.enemies = backup.enemies;
        state.towers = backup.towers;
        state.tech = backup.tech;
        state.items = backup.items;
        state.wave = backup.wave;
        state.enemiesToSpawn = backup.enToSpawn;
        state.spawnedThisWave = backup.spc;
        state.drops = backup.drops;
        state.toasts = backup.toasts;
      }
      if (errors.length === 0) console.log('%cSanity tests passed', 'color:#7ee787');
      else console.error('Sanity test failures:', errors);
    }

    // Kickoff
    resize();
    reset(true);
    runSanityTests();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
